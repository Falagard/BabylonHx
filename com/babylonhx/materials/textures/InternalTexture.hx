package com.babylonhx.materials.textures;

import com.babylonhx.engine.DepthTextureCreationOptions;
import com.babylonhx.engine.Engine;
import com.babylonhx.tools.Observable;
import com.babylonhx.ISmartArrayCompatible;
import com.babylonhx.math.SphericalPolynomial;

import com.babylonhx.utils.typedarray.ArrayBuffer;
import com.babylonhx.utils.typedarray.ArrayBufferView;
import com.babylonhx.utils.GL.GLTexture;
import com.babylonhx.utils.GL.GLFramebuffer;
import com.babylonhx.utils.GL.GLRenderbuffer;

/**
 * ...
 * @author Krtolica Vujadin
 */

/**
 * Class used to store data associated with WebGL texture data for the engine
 * This class should not be used directly
 */
class InternalTexture implements ISmartArrayCompatible implements IInternalTextureTracker {
	
	/**
	 * The source of the texture data is unknown
	 */
	public static inline var DATASOURCE_UNKNOWN:Int = 0;
	/**
	 * Texture data comes from an URL
	 */
	public static inline var DATASOURCE_URL:Int = 1;
	/**
	 * Texture data is only used for temporary storage
	 */
	public static inline var DATASOURCE_TEMP:Int = 2;
	/**
	 * Texture data comes from raw data (ArrayBuffer)
	 */
	public static inline var DATASOURCE_RAW:Int = 3;
	/**
	 * Texture content is dynamic (video or dynamic texture)
	 */
	public static inline var DATASOURCE_DYNAMIC:Int = 4;
	/**
	 * Texture content is generated by rendering to it
	 */
	public static inline var DATASOURCE_RENDERTARGET:Int = 5;
	/**
	 * Texture content is part of a multi render target process
	 */
	public static inline var DATASOURCE_MULTIRENDERTARGET:Int = 6;
	/**
	 * Texture data comes from a cube data file
	 */
	public static inline var DATASOURCE_CUBE:Int = 7;
	/**
	 * Texture data comes from a raw cube data
	 */
	public static inline var DATASOURCE_CUBERAW:Int = 8;
	/**
	 * Texture data come from a prefiltered cube data file
	 */
	public static inline var DATASOURCE_CUBEPREFILTERED:Int = 9;
	/**
	 * Texture content is raw 3D data
	 */
	public static inline var DATASOURCE_RAW3D:Int = 10;
	/**
     * Texture content is a depth texture
     */
    public static inline var DATASOURCE_DEPTHTEXTURE:Int = 11;

	/**
	 * Defines if the texture is ready
	 */
	public var isReady:Bool = false;
	/**
	 * Defines if the texture is a cube texture
	 */
	public var isCube:Bool = false;
	/**
	 * Defines if the texture contains 3D data
	 */
	public var is3D:Bool = false;
	/**
	 * URL used to load this texture
	 */
	public var url:String;
	/**
	 * Sampling mode of the texture
	 */
	public var samplingMode:Int;
	/**
	 * Indicating if the texture needs mipmaps generation
	 */
	public var generateMipMaps:Bool;
	/**
	 * Number of samples used by the texture (WebGL2+ only)
	 */
	public var samples:Int;
	/**
	 * Type of the texture
	 */
	public var type:Int = -1;
	/**
	 * Format of the texture 
	 */
	public var format:Int;
	/**
	 * Observable called when the texture is loaded
	 */
	public var onLoadedObservable:Observable<InternalTexture> = new Observable<InternalTexture>();
	/**
	 * Width of the texture
	 */
	public var width:Int = 1;
	/**
	 * Height of the texture
	 */
	public var height:Int = 1;
	/**
	 * Depth of the texture
	 */
	public var depth:Int = 1;
	/**
	 * Initial width of the texture (It could be rescaled if the current system does not support non power of two textures)
	 */
	public var baseWidth:Int = 1;
	/**
	 * Initial height of the texture (It could be rescaled if the current system does not support non power of two textures)
	 */
	public var baseHeight:Int = 1;
	/**
	 * Initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)
	 */
	public var baseDepth:Int = 1;
	/**
	 * Boolean indicating if the texture is inverted on Y axis
	 */
	public var invertY:Bool = false;
	
	/**
	 * Gets or set the previous tracker in the list
	 */
	public var previous:IInternalTextureTracker = null;
	/**
	 * Gets or set the next tracker in the list
	 */
	public var next:IInternalTextureTracker = null;

	// Private
	public var _initialSlot:Int = -1;
	public var _designatedSlot:Int = -1;
	public var _dataSource:Int = InternalTexture.DATASOURCE_UNKNOWN;
	public var _buffer:ArrayBuffer;
	public var _bufferView:ArrayBufferView;
	public var _bufferViewArray:Array<ArrayBufferView>;
	public var _size:Int = -1;
	public var _extension:String;
	public var _files:Array<String>;
	//public var _workingCanvas:HTMLCanvasElement;
	//public var _workingContext:CanvasRenderingContext2D;
	public var _framebuffer:GLFramebuffer;
	public var _depthStencilBuffer:GLRenderbuffer;
	public var _MSAAFramebuffer:GLFramebuffer;
	public var _MSAARenderBuffer:GLRenderbuffer;
	public var _attachments:Array<Int> = null;
	public var _cachedCoordinatesMode:Int = -1;
	public var _cachedWrapU:Int = -1;
	public var _cachedWrapV:Int = -1;
	public var _cachedWrapR:Int = -1;
	public var _cachedAnisotropicFilteringLevel:Int = -1;
	public var _isDisabled:Bool;
	public var _compression:String;
	public var _generateStencilBuffer:Bool;
	public var _generateDepthBuffer:Bool;
	public var _comparisonFunction:Int = 0;
	public var _sphericalPolynomial:SphericalPolynomial;
	public var _lodGenerationScale:Float;
    public var _lodGenerationOffset:Float;
	
	// The following three fields helps sharing generated fixed LODs for texture filtering
	// In environment not supporting the textureLOD extension like EDGE. They are for internal use only.
	// They are at the level of the gl texture to benefit from the cache.
	public var _lodTextureHigh:BaseTexture;
	public var _lodTextureMid:BaseTexture;
	public var _lodTextureLow:BaseTexture;
	
	public var _webGLTexture:GLTexture;
	public var _references:Int = 1;
	private var _engine:Engine;
	
	public var dataSource(get, never):Int;
	/**
	 * Gets the data source type of the texture (can be one of the BABYLON.InternalTexture.DATASOURCE_XXXX)
	 */
	inline private function get_dataSource():Int {
		return this._dataSource;
	}
	
	public var __smartArrayFlags:Array<Int> = [];
	

	/**
	 * Creates a new InternalTexture
	 * @param engine defines the engine to use
	 * @param dataSource defines the type of data that will be used
	 */
	public function new(engine:Engine, dataSource:Int) {
		this._engine = engine;
		this._dataSource = dataSource;
		
		this._webGLTexture = engine._createTexture();
	}

	/**
	 * Increments the number of references (ie. the number of {BABYLON.Texture} that point to it)
	 */
	public function incrementReferences() {
		this._references++;
	}

	/**
	 * Change the size of the texture (not the size of the content)
	 * @param width defines the new width
	 * @param height defines the new height
	 * @param depth defines the new depth (1 by default)
	 */
	public function updateSize(width:Int, height:Int, depth:Int = 1) {
		this.width = width;
		this.height = height;
		this.depth = depth;
		
		this.baseWidth = width;
		this.baseHeight = height;
		this.baseDepth = depth;
		
		this._size = Std.int(width * height * depth);
	}
	
	public function _rebuild() {
		var proxy:InternalTexture = null;
		this.isReady = false;
		this._cachedCoordinatesMode = -1;
		this._cachedWrapU = -1;
		this._cachedWrapV = -1;
		this._cachedAnisotropicFilteringLevel = -1;
		
		switch (this._dataSource) {
			case InternalTexture.DATASOURCE_TEMP:
				return;
				
			case InternalTexture.DATASOURCE_URL:
				proxy = this._engine.createTexture(this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, function() {
					this.isReady = true;
				}, null, this._buffer, null, this.format); 
				proxy._swapAndDie(this);
				return;
				
			case InternalTexture.DATASOURCE_RAW:
                proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression); 
                proxy._swapAndDie(this);
				this.isReady = true;
				return;
				
			case InternalTexture.DATASOURCE_RAW3D:
                proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
                proxy._swapAndDie(this);
				
                this.isReady = true;
				return;
				
			case InternalTexture.DATASOURCE_DYNAMIC:
				proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode); 
				proxy._swapAndDie(this);
				
				// The engine will make sure to update content so no need to flag it as isReady = true
				return;
				
			case InternalTexture.DATASOURCE_RENDERTARGET:
				var options:RenderTargetCreationOptions = new RenderTargetCreationOptions();
				options.generateDepthBuffer = this._generateDepthBuffer;
				options.generateMipMaps = this.generateMipMaps;
				options.generateStencilBuffer = this._generateStencilBuffer;
				options.samplingMode = this.samplingMode;
				options.type = this.type;
				
				if (this.isCube) {
					proxy = this._engine.createRenderTargetCubeTexture(this.width, options); 
				} 
				else {
					var size = {
						width: this.width,
						height: this.height
					}
					
					proxy = this._engine.createRenderTargetTexture(size, options); 
				}
				proxy._swapAndDie(this);
				
				this.isReady = true;
                return;
				
			case InternalTexture.DATASOURCE_DEPTHTEXTURE:
                var depthTextureOptions:DepthTextureCreationOptions = {
                    bilinearFiltering: this.samplingMode != Texture.BILINEAR_SAMPLINGMODE,
                    comparisonFunction: this._comparisonFunction,
                    generateStencil: this._generateStencilBuffer,
                };
				
                if (this.isCube) {
                    proxy = this._engine.createDepthStencilTexture({ width: this.width, height: this.height }, depthTextureOptions);
                } 
				else {
                    proxy = this._engine.createDepthStencilCubeTexture(this.width, depthTextureOptions);
                }
                proxy._swapAndDie(this);
				
                this.isReady = true;
                return;
				
			case InternalTexture.DATASOURCE_CUBE:
				proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, function() {
					this.isReady = true;
				}, null, this.format, this._extension);
				proxy._swapAndDie(this);
				return;
				
			case InternalTexture.DATASOURCE_CUBERAW:
                proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
                proxy._swapAndDie(this);
				
                this.isReady = true;
                return;
				
			case InternalTexture.DATASOURCE_CUBEPREFILTERED:
				proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, function(proxy:InternalTexture) {
					if (proxy != null) {
						proxy._swapAndDie(this);
					}
					
					this.isReady = true;
				}, null, this.format, this._extension);
				return;
		}
    }
	
	private function _swapAndDie(target:InternalTexture) {
		target._webGLTexture = this._webGLTexture;
		
		if (this._framebuffer != null) {
			target._framebuffer = this._framebuffer;
		}
		
		if (this._depthStencilBuffer != null) {
			target._depthStencilBuffer = this._depthStencilBuffer;
		}
		
		if (this._lodTextureHigh != null) {
			if (target._lodTextureHigh != null) {
                target._lodTextureHigh.dispose();
            }
			target._lodTextureHigh = this._lodTextureHigh;
		}
		
		if (this._lodTextureMid != null) {
			if (target._lodTextureMid != null) {
                target._lodTextureMid.dispose();
            }  
			target._lodTextureMid = this._lodTextureMid;
		}
		
		if (this._lodTextureLow != null) {
			if (target._lodTextureLow != null) {
                target._lodTextureLow.dispose();
            }
			target._lodTextureLow = this._lodTextureLow;
		}
		
		var cache = this._engine.getLoadedTexturesCache();
		var index = cache.indexOf(this);
		if (index != -1) {
			cache.splice(index, 1);
		}
	}
	
	/**
	 * Dispose the current allocated resources
	 */
	public function dispose() {
		if (this._webGLTexture == null) {
			return;
		}
		
		this._references--;
		if (this._references == 0) {			
			this._engine._releaseTexture(this);
			this._webGLTexture = null;
			this.previous = null;
			this.next = null;
		}
	}
	
}
